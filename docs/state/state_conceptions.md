# Концепции использования MobX-сторов

## Создание сторов

- Стор всегда является **классом-синглтоном**, т.е. из файла, где он описывается, **экспортируется только экземпляр класса**.
- Для каждого изменения, будь то **геттер/сеттер** или **computed-свойство**, пишется **отдельный метод**.
- За **наиредчайшим исключением** методы делаются **как arrow-function**. Исключение — случай, когда контекст должен принадлежать другому классу.
- **Минимальный размер стора** — внутри должны находиться только данные, относящиеся к одной и той же бизнес-логике.
- В **сторах не должно быть асинхронных операций**, за исключением случаев с **WebSocket-соединениями**.
- Если необходимо сохранять **async состояние**, создаем для него **поля, геттеры, сеттеры** и управляем им **вне стора**.

## Использование сторов

- При использовании всегда **разыменовываем стор**, например:

  ```ts
  import store from "@/store.ts"

  export const Component = observable(() => {
      const { state, reduceState } = store 
  })
  ```

- **MobX предпочитает маленькие компоненты** — чем меньше наблюдаемых свойств внутри компонента, тем лучше.  
  - Это правило **не относится** к случаям, когда используются только **reducer-ы**.  
  - Предпочтительно **много маленьких компонентов с observable**, а не **меньше компонентов с большим количеством состояния**.

- **Не стоит использовать стор для локального состояния.**  
  - Например, если у нас есть **список продуктов**, а отдельный компонент отвечает за рендер **одного продукта**, данные передаются **через props**, а не через стор.

---

_В дальнейшем могут быть добавлены новые концепции._
